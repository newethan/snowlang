mod Bitreg {
public:
    # input
    let or data;
    let or set;
    let or read;

    # ouput
    let and value;

private:
    let xor mem;
    con mem mem;
    let or reset;
    let and switch_on;
    let and flip_if_on;
    con set reset;
    con reset flip_if_on;
    con mem flip_if_on;
    con flip_if_on mem;
    con set switch_on;
    con data switch_on;
    con switch_on mem;
    con mem value;
    con read value;
}

mod Reg {
public:
    # input
    let or[8] data;
    let and set;
    let and read;

    #output
    let or[8] value;

private:
    let Bitreg[8] registers;
    for $n in (0, 7) {
        con data[$n] registers[$n].data;
        con set registers[$n].set;
        con read registers[$n].read;
        con registers[$n].value value[$n];
    }
}

mod Multiplexer {
public:
    # input
    let or[8] address;

    # output
    let and[256] board;

private:
    let nor[8] neg;
    con address neg;
    for $n in (0, 7) {
        for $m in (0,255) {
            if (is $m % 2**$n < 2**$n / 2) {
                con address.data[$n] board[$m];
            }
            else {
                con neg[$n] board[$m];
            }
        }
    }
}

mod Ram {
public:
    # input
    let or[8] address;
    let or[8] data;
    let or write;
    let or read;
    
    # output
    let or[8] out;

private:
    let Multiplexer mult;
    let Reg[256] regs;
    con address mult.address;
    for $n in (0, 255) {
        con set regs[$n].set;
        con read regs[$n].read;
        con mult.board[$n] regs[$n].set;
        con mult.board[$n] regs[$n].read;
        con regs[$n].value out;
        con data regs[$n].data;
    }
}

mod Main {
public:

private:
    let Ram ram; 
}