mod bitreg {
in:
    or data;
    or set;
    or read;
out:
    and value;
cons:
    @ xor mem;
    = mem mem;
    @ or reset;
    @ and switch_on;
    @ and flip_if_on;
    = set reset;
    = reset flip_if_on;
    = mem flip_if_on;
    = flip_if_on mem;
    = set switch_on;
    = data switch_on;
    = switch_on mem;
    = mem value;
    = read value;
}

mod reg {
in:
    [8]or data;
    and set;
    and read;
out:
    [8]or value;
cons:
    @ [8]onebitreg registers;
    loop $n in (0, 7) {
        = data[$n] registers[$n].data;
        = set registers[$n].set;
        = read registers[$n].read;
        = registers[$n].value value[$n];
    }
}

mod multiplexer {
in:
    [8]or address;
out:
    [256]and board;
cons:
    @ [8]nor neg;
    = address neg;
    loop $n in (0, 7) {
        loop $m in (0,255) {
            if (is $m % 2**$n < 2**$n / 2) {
                = address.data[$n] board[$m];
            }
            else {
                = neg[$n] board[$m];
            }
        }
    }
}

mod ram{
in:
    [8]or address;
    [8]or data;
    or write;
    or read;
out:
    [8]or out;
cons:
    @ multiplexer mult;
    @ [256]reg regs;
    = address mult.address;
    loop $n in (0, 255) {
        = set regs[$n].set;
        = read regs[$n].read;
        = mult.board[$n] regs[$n].set;
        = mult.board[$n] regs[$n].read;
        = regs[$n].value out;
        = data regs[$n].data;
    }
}

