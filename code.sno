let pow(base, exponent) {
    result = 1;
    for n in (1, exponent) {
        result = result * base;
    }
    return result;
}

let modulo(number, modulo) {
    if number < modulo {
        return number;
    }
    result = number;
    while result >= modulo {
        result = result - modulo;
    }
    return result;
}

mod Bitreg {
    # input
    let or data;
    let or set;
    let or read;

    # ouput
    let and value;

    let xor mem;
    con mem mem;
    let or reset;
    let and switch_on;
    let and flip_if_on;
    con set reset;
    con reset flip_if_on;
    con mem flip_if_on;
    con flip_if_on mem;
    con set switch_on;
    con data switch_on;
    con switch_on mem;
    con mem value;
    con read value;
}

mod Reg {
    # input
    let or[8] data;
    let and set;
    let and read;

    #output
    let or[8] value;

    let Bitreg[8] registers;
    for n in (0, 7) {
        con data[n] registers[n].data;
        con set registers[n].set;
        con read registers[n].read;
        con registers[n].value value[n];
    }
}

mod Multiplexer {
    # input
    let or[8] address;

    # output
    let and[256] board;

    let nor[8] neg;
    con address neg;
    for n in (0, 7) {
        for m in (0,255) {
            # if (modulo(m, pow(2,n)) < pow(2,n) / 2)
            if (m % 2**n < 2**n / 2) {
                con address[n] board[m];
            }
            else {
                con neg[n] board[m];
            }
        }
    }
}

mod Ram {
    # input
    let or[8] address;
    let or[8] data;
    let or write;
    let or read;
    
    # output
    let or[8] out;

    let Multiplexer mult;
    let Reg[256] regs;
    con address mult.address;
    for n in (0, 255) {
        con set regs[n].set;
        con read regs[n].read;
        con mult.board[n] regs[n].set;
        con mult.board[n] regs[n].read;
        con regs[n].value out;
        con data regs[n].data;
    }
}

mod Main {

    let Ram ram; 
}