import "multiplexer.sno";

mod Reg (bits, inc_dec = false, inp_or = false, q)
{
    # input
    let and data[bits];
    if inp_or
    {
        let or set;
        let or read;
        if inc_dec
        {
            let or inc;
            let or dec;
        }
    }
    else
    {
        let and set;
        let and read;
        if inc_dec
        {
            let and inc;
            let and dec;
        }
    }

    # output
    let and out[bits];

    # memory
    let xor mem[bits];
    con mem mem;

    # reset
    let and reset[bits];
    con mem reset;
    con reset mem;

    # set
    con data mem;
    for i in (0, bits - 1)
    {
        con set data[i];
        con set reset[i];
    }

    # read
    con mem out;
    for i in (0,  bits - 1)
    {
        con read out[i];
    }

    # increment and decrement
    if inc_dec
    {
        let xor inv_mem[bits];
        let and flip[bits];
        con flip mem;
        con mem inv_mem;

        if inp_or
        {
            for i in (0, bits - 1)
            {
                con dec inv_mem[i];
                con inc flip[i];
            }
            con dec inc;
        }
        else
        {
            let or or_inc;
            let or or_dec;
            con inc or_inc;
            con dec or_dec;

            for i in (0, bits - 1)
            {
                con or_dec inv_mem[i];
                con or_inc flip[i];
            }
            con or_dec or_inc;
        }

        for i in (1, bits - 1)
        {
            for j in (0, i - 1)
            {
                con inv_mem[j] flip[i];
            }
        }
    }
}

mod SncomputerRegs
    (bits,stackp_bits, inst_bits, regid_bits, num_gen_purpose)
{
    # general purpose registers A-J
    # bin 0000 - 1001
    let Reg(bits, true, false) gen_purpose[num_gen_purpose];
    # alu output register
    let Reg(bits, false, false) l; # bin 1010
    # general purpose bit register
    let Reg(1, false, false) q; # bin 1011
    # equality flag
    let Reg(1, false, false) eq; # bin 1100
    # less than flag
    let Reg(1, false, false) lt; # bin 1101
    # greater than than flag
    let Reg(1, false, false) gt; # bin 1110
    # Ram address -
    # pointer to address in memory of current instruction
    let Reg(bits, true, false) ra; # bin 1111

    let Multiplexer(regid_bits) mult;
    for i in (0, num_gen_purpose - 1)
    {
        con mult.board[i] gen_purpose[i].read;
        con mult.board[i] gen_purpose[i].set;
        con mult.board[i] gen_purpose[i].inc;
        con mult.board[i] gen_purpose[i].dec;
    }
    con mult.board[10] l.read;
    con mult.board[10] l.set;
    con mult.board[11] q.read;
    con mult.board[11] q.set;
    con mult.board[12] eq.read;
    con mult.board[12] eq.set;
    con mult.board[13] lt.read;
    con mult.board[13] lt.set;
    con mult.board[14] gt.read;
    con mult.board[14] gt.set;
    con mult.board[15] ra.read;
    con mult.board[15] ra.set;
    con mult.board[15] ra.inc;
    con mult.board[15] ra.dec;

    let or set;
    let or read;
    let or inc;
    let or dec;
    for i in (0, num_gen_purpose - 1)
    {
        con set gen_purpose[i].set;
        con read gen_purpose[i].read;
        con inc gen_purpose[i].inc;
        con dec gen_purpose[i].dec;
    }
    con set l.set;
    con read l.read;
    con set q.set;
    con read q.read;
    con set eq.set;
    con read eq.read;
    con set lt.set;
    con read lt.read;
    con set gt.set;
    con read gt.read;
    con set ra.set;
    con read ra.read;
    con inc ra.inc;
    con dec ra.dec;


    # internal registers
    let Reg(inst_bits, false, true) instruction; # current instruction
    let Reg(bits, false, true) ip1; # 1st instruction parameter
    let Reg(bits, false, true) ip2; # 2nd instruction parameter
    let Reg(stackp_bits, true, true) stackp; # stack pointer
    # (stackp_bits bits - 2**stackp_bits bytes in stack!)
    let Reg(bits, true, true) stepc; # step counter
}

mod Ram (bits)
{
    # input
    let or address[bits];
    let or data[bits];
    let or set;
    let or read;

    # output
    let or out[bits];

    let Multiplexer(bits) mult;
    let Reg(bits, false, false) regs[2**bits];
    con address mult.address;

    for i in (0, 2**bits - 1)
    {
        con set regs[i].set;
        con read regs[i].read;
        con mult.board[i] regs[i].set;
        con mult.board[i] regs[i].read;
        con regs[i].out out;
        con data regs[i].data;
    }
}