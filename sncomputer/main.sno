# Main file for the snowlang computer -
# A logical computer written in snowlang

import "mem.sno";
import "multiplexer.sno";
import "alu.sno";
import "util.sno";

mod Main
{
    # number of bits used in the computer
    # (memory space will be extended to accomodate all addresses possible
    # with the given number of bits)

    # WARNING!!!
    # build time increases exponentially with the number of bits.
    # ADVISED 16 AS MAX NUMBER OF BITS (should take about 20 seconds to build).
    bits = 8;

    # number of bits in the stack pointer (stack has 2**stackp_bits bytes)
    stackp_bits = 8;

    # number of bits in instruction (required inst_bits <= bits)
    inst_bits = 5;

    # number of  bits in register id
    regid_bits = 4;

    ##############
    # bus
    ##############
    let or bus[bits];

    ##############
    # registers 
    ##############
    num_gen_purpose = 10;
    let SncomputerRegs
        (bits, stackp_bits, inst_bits, regid_bits, num_gen_purpose) regs;
    # connect registers data and output to bus.
    for i in (0, num_gen_purpose - 1)
    {
        con bus regs.gen_purpose[i].data;
    }
    con bus regs.l.data;
    con bus[0] regs.q.data[0];
    con bus[0] regs.eq.data[0];
    con bus[0] regs.lt.data[0];
    con bus[0] regs.gt.data[0];
    con bus regs.ra.data;
    for i in (0, inst_bits - 1)
    {
        con bus[i] regs.instruction.data[i];
    }
    con bus regs.ip1.data;
    con bus regs.ip2.data;
    con bus regs.stackp.data;
    con bus regs.stepc.data;

    for i in (0, num_gen_purpose - 1)
    {
        con regs.gen_purpose[i].out bus;
    }
    con regs.l.out bus;
    con regs.q.out[0] bus[0];
    con regs.eq.out[0] bus[0];
    con regs.lt.out[0] bus[0];
    con regs.gt.out[0] bus[0];
    con regs.ra.out bus;
    for i in (0, inst_bits - 1)
    {
        con regs.instruction.out[i] bus[i];
    }
    con regs.ip1.out bus;
    con regs.ip2.out bus;
    con regs.stackp.out bus;
    con regs.stepc.out bus;

    let Selector(bits, 2) regs_selector;
    con regs.ip1.mem regs_selector.words[0].word;
    con regs.ip2.mem regs_selector.words[1].word;
    for i in (0, regid_bits - 1)
    {
        con regs_selector.out[i] regs.mult.address[i];
    }


    ##############
    # ram
    ##############
    let Ram(bits) ram;
    let Selector(bits, 2) ram_selector;
    con regs.stepc.mem ram_selector.words[0].word;
    con regs.ra.mem ram_selector.words[1].word;
    con ram_selector.out ram.mult.address;

    con bus ram.data;
    con ram.out bus;

    ##############
    # ALU
    ##############
    let ALU(bits) alu;
    con regs.ip1.mem alu.a;
    con regs.ip2.mem alu.b;
    con alu.out bus;

    ##############
    # processor 
    ##############

    # main tick signal - give 1 tick pulse to activate computer
    let or cpu_tick;

    # instruction multiplexer
    let Multiplexer(inst_bits) mult;
    con regs.instruction.mem mult.address;

    # every time cpu tick is given
    let or cpu_tick_a;
    let Timer(7) cpu_tick_b;
    let Timer(4) cpu_tick_c;
    let Timer(4) cpu_tick_d;
    con cpu_tick cpu_tick_a;
    con cpu_tick_a cpu_tick_b.inp;
    con cpu_tick_b.out cpu_tick_c.inp;
    con cpu_tick_c.out cpu_tick_d.inp;

    con cpu_tick_a ram_selector.select[0];
    con cpu_tick_b.out ram.read;
    con cpu_tick_c.out regs.instruction.or_set;
    for i in (0, 2**inst_bits - 1)
    {
        con cpu_tick_d.out mult.board[i];
    }

    # HLT - bin 00000
    # nothing to do

    # LDR - Load register. Bin 00001
    # 1. increment stepc - then 6 tick delay
    # 2. read ram - then 4 tick delay
    # 3. set ip1
    #    change ram address selection to regs.ra.mem (mode 1)
    #    change register selection to ip1.mem (mode 0)
    #    - then 7 tick delay
    # 4. read ram - then 2 tick delay
    # 5. set regs
    #    increment stepc
    #    cpu_tick
    let or ldr_1;
    let Timer(6) ldr_2;
    let Timer(4) ldr_3;
    let Timer(7) ldr_4;
    let Timer(2) ldr_5;
    con mult.board[1] ldr_1;
    con ldr_1 ldr_2.inp;
    con ldr_2.out ldr_3.inp;
    con ldr_3.out ldr_4.inp;
    con ldr_4.out ldr_5.inp;

    con ldr_1 regs.stepc.or_inc;            # 1
    con ldr_2.out ram.read;                 # 2
    con ldr_3.out regs.ip1.or_set;          # 3(a)
    con ldr_3.out ram_selector.select[1];   # 3(b)
    con ldr_3.out regs_selector.select[0];  # 3(c)
    con ldr_4.out ram.read;                 # 4
    con ldr_5.out regs.set;                 # 5(a)
    con ldr_5.out regs.stepc.or_inc;        # 5(b)
    con ldr_5.out cpu_tick;                 # 5(c)

    # STR - Store register. Bin 00010
    # 1. increment stepc - then 6 tick delay
    # 2. read ram - then 3 tick delay
    # 3. set ip1
    #    change ram address selection to regs.ra.mem (mode 1)
    #    change register selection to ip1.mem (mode 0)
    #    - then 7 tick delay
    # 4. read regs - then 2 tick delay
    # 5. set ram
    #    increment stepc
    #    cpu_tick
    let or str_1;
    let Timer(6) str_2;
    let Timer(3) str_3;
    let Timer(7) str_4;
    let Timer(2) str_5;
    con mult.board[2] str_1;
    con str_1 str_2.inp;
    con str_2.out str_3.inp;
    con str_3.out str_4.inp;
    con str_4.out str_5.inp;

    con str_1 regs.stepc.or_inc;              # 1
    con str_2.out ram.read;                # 2
    con str_3.out regs.ip1.or_set;            # 3(a)
    con str_3.out ram_selector.select[1];  # 3(b)
    con str_3.out regs_selector.select[0]; # 3(c)
    con str_4.out regs.read;               # 4
    con str_5.out ram.set;                 # 5(a)
    con str_5.out regs.stepc.or_inc;          # 5(b)
    con str_5.out cpu_tick;                # 5(c)

    # SER - Set register. Bin 00011
    # 1. increment stepc - then 6 tick delay
    # 2. read ram - then 4 tick delay
    # 3. set ip1
    #    increment stepc
    #    - then 6 tick delay
    # 4. read ram - then 4 tick delay
    # 5. set ip2
    #    change register selection to ip1.mem (mode 0)
    #    - then 7 tick delay
    # 6. read ip2
    #    set regs
    #    increment stepc
    #    cpu_tick
    let or ser_1;
    let Timer(6) ser_2;
    let Timer(4) ser_3;
    let Timer(6) ser_4;
    let Timer(4) ser_5;
    let Timer(7) ser_6;
    con mult.board[3] ser_1;
    con ser_1 ser_2.inp;
    con ser_2.out ser_3.inp;
    con ser_3.out ser_4.inp;
    con ser_4.out ser_5.inp;
    con ser_5.out ser_6.inp;

    con ser_1 regs.stepc.or_inc;           # 1
    con ser_2.out ram.read;                # 2
    con ser_3.out regs.ip1.or_set;         # 3(a)
    con ser_3.out regs.stepc.or_inc;       # 3(b)
    con ser_4.out ram.read;                # 4
    con ser_5.out regs.ip2.or_set;         # 5(a)
    con ser_5.out regs_selector.select[0]; # 5(b)
    con ser_6.out regs.ip2.or_read;        # 6 (a)
    con ser_6.out regs.set;                # 6(b)
    con ser_6.out regs.stepc.or_inc;       # 6(c)
    con ser_6.out cpu_tick;                # 6(d)

    # MOV - Moves value from one register to another. Bin 00100
    # 1. increment stepc - then 6 tick delay
    # 2. read ram - then 4 tick delay
    # 3. set ip1
    #    increment stepc
    #    - then 6 tick delay
    # 4. read ram - then 4 tick delay
    # 5. set ip2
    #    change register selection to ip1.mem (mode 0)
    #    - then 7 tick delay
    # 6. read regs - then 3 tick delay
    # 7. set ip1
    #    change register selection to ip2.mem (mode 1)
    #    - then 7 tick delay
    # 8. read ip1
    #    set regs
    #    increment stepc
    #    cpu_tick
    let or mov_1;
    let Timer(6) mov_2;
    let Timer(4) mov_3;
    let Timer(6) mov_4;
    let Timer(4) mov_5;
    let Timer(7) mov_6;
    let Timer(3) mov_7;
    let Timer(7) mov_8;
    con mult.board[4] mov_1;
    con mov_1 mov_2.inp;
    con mov_2.out mov_3.inp;
    con mov_3.out mov_4.inp;
    con mov_4.out mov_5.inp;
    con mov_5.out mov_6.inp;
    con mov_6.out mov_7.inp;
    con mov_7.out mov_8.inp;

    con mov_1 regs.stepc.or_inc;              # 1
    con mov_2.out ram.read;                   # 2
    con mov_3.out regs.ip1.or_set;            # 3(a)
    con mov_3.out regs.stepc.or_inc;          # 3(b)
    con mov_4.out ram.read;                   # 4
    con mov_5.out regs.ip2.or_set;            # 5(a)
    con mov_5.out regs_selector.select[0];    # 5(b)
    con mov_6.out regs.read;                  # 6
    con mov_7.out regs.ip1.or_set;            # 7(a)
    con mov_7.out regs_selector.select[1];    # 7(b)
    con mov_8.out regs.ip1.or_read;           # 8(a)
    con mov_8.out regs.set;                   # 8(b)
    con mov_8.out regs.stepc.or_inc;          # 8(c)
    con mov_8.out cpu_tick;                   # 8(d)

    # # INC - Increment register. Bin 00101
    # # 1. increment stepc - then 6 tick delay
    # # 2. read ram - then 3 tick delay
    # # 3. set ip1
    # #    change register selection to ip1.mem (mode 0)
    # #    - then 7 tick delay
    # # 4. increment regs
    # #    increment stepc
    # #    cpu_tick
    # let or inc_1;
    # let Timer(6) inc_2;
    # let Timer(3) inc_3;
    # let Timer(7) inc_4;
    # con mult.board[5] inc_1;
    # con inc_1 inc_2.inp;
    # con inc_2.out inc_3.inp;
    # con inc_3.out inc_4.inp;

    # con inc_1 regs.stepc.inc;              # 1
    # con inc_2.out ram.read;                # 2
    # con inc_3.out regs.ip1.set;            # 3(a)
    # con inc_3.out regs_selector.select[0]; # 3(b)
    # con inc_4.out regs.inc;                # 4(a)
    # con inc_4.out regs.stepc.inc;          # 4(b)
    # con inc_4.out cpu_tick;                # 4(c)

    # # DEC - Decrement register. Bin 00110
    # # 1. increment stepc - then 6 tick delay
    # # 2. read ram - then 3 tick delay
    # # 3. set ip1
    # #    change register selection to ip1.mem (mode 0)
    # #    - then 7 tick delay
    # # 4. decrement regs
    # #    increment stepc
    # #    cpu_tick
    # let or dec_1;
    # let Timer(6) dec_2;
    # let Timer(3) dec_3;
    # let Timer(7) dec_4;
    # con mult.board[6] dec_1;
    # con dec_1 dec_2.inp;
    # con dec_2.out dec_3.inp;
    # con dec_3.out dec_4.inp;

    # con dec_1 regs.stepc.inc;              # 1
    # con dec_2.out ram.read;                # 2
    # con dec_3.out regs.ip1.set;            # 3(a)
    # con dec_3.out regs_selector.select[0]; # 3(b)
    # con dec_4.out regs.dec;                # 4(a)
    # con dec_4.out regs.stepc.inc;          # 4(b)
    # con dec_4.out cpu_tick;                # 4(c)

    # # ADD - Add contents of two registers. Bin 00111
    # # 1. increment stepc - then 6 tick delay
    # # 2. read ram - then 3 tick delay
    # # 3. set ip1
    # #    increment stepc
    # #    - then 6 tick delay
    # # 4. read ram - then 3 tick delay
    # # 5. set ip2
    # #    change register selection to ip1.mem (mode 0)
    # #    - then 7 tick delay
    # # 6. read regs - then 2 tick delay
    # # 7. set ip1
    # #    change register selection to ip2.mem (mode 1)
    # #    - then 7 tick delay
    # # 8. read regs - then 2 tick delay
    # # 9. set ip2 - then ??? tick delay
    # # 10. read ALU adder-subtractor - then ??? tick delay
    # # 11. set l
    # #     increment stepc
    # #      cpu_tick
    # let or add_1;
    # let Timer(6) add_2;
    # let Timer(3) add_3;
    # let Timer(6) add_4;
    # let Timer(3) add_5;
    # let Timer(7) add_6;
    # let Timer(2) add_7;
    # let Timer(7) add_8;
    # let Timer(2) add_9;
    # let Timer(50) add_10; # enough for ripple carry to finish
    # let Timer(5) add_11;
    # con mult.board[7] add_1;
    # con add_1 add_2.inp;
    # con add_2.out add_3.inp;
    # con add_3.out add_4.inp;
    # con add_4.out add_5.inp;
    # con add_5.out add_6.inp;
    # con add_6.out add_7.inp;
    # con add_7.out add_8.inp;
    # con add_8.out add_9.inp;
    # con add_9.out add_10.inp;
    # con add_10.out add_11.inp;

    # con add_1 regs.stepc.inc;              # 1
    # con add_2.out ram.read;                # 2
    # con add_3.out regs.ip1.set;            # 3(a)
    # con add_3.out regs.stepc.inc;          # 3(b)
    # con add_4.out ram.read;                # 4
    # con add_5.out regs.ip2.set;            # 5(a)
    # con add_5.out regs_selector.select[0]; # 5(b)
    # con add_6.out regs.read;               # 6
    # con add_7.out regs.ip1.set;            # 7(a)
    # con add_7.out regs_selector.select[1]; # 7(b)
    # con add_8.out regs.read;               # 8
    # con add_9.out regs.ip2.set;            # 9
    # con add_10.out alu.op_byte[0];         # 10
    # con add_11.out regs.l.set;             # 11(a)
    # con add_11.out regs.stepc.inc;         # 11(b)
    # con add_11.out cpu_tick;               # 11(c)
}

let runtime ()
{
    hold regs.ra.mem 00010001 1;
    hold regs.gen_purpose[1].mem 11110000 1;

    hold ram.regs[0].mem  00000100 1;
    hold ram.regs[1].mem  00000001 1;
    hold ram.regs[2].mem  00000000 1; 
    hold ram.regs[3].mem  00000000 1; #
    hold ram.regs[4].mem  00000010 1;
    hold ram.regs[5].mem  00000011 1;
    hold ram.regs[6].mem  00000111 1;
    hold ram.regs[7].mem  00000001 1;
    hold ram.regs[8].mem  00000010 1;
    hold ram.regs[9].mem  00000000 1; #
    hold ram.regs[10].mem 00000000 1;
    hold ram.regs[11].mem 00000000 1;
    hold ram.regs[12].mem 00000000 1;
    hold ram.regs[13].mem 00000000 1;
    hold ram.regs[14].mem 00000000 1;
    hold ram.regs[15].mem 00000000 1;
    hold ram.regs[16].mem 00000000 1;
    hold ram.regs[17].mem 11100111 1;


    tick 10;
    hold cpu_tick 1 1;
    for i in (0, 250)
    {
        print "------------$0------------\n", i;
        print "bus is ";
        print bus;
        print "\n";
        print "instruction is ";
        print regs.instruction.mem;
        print "\n";
        print "ip1 is ";
        print regs.ip1.mem;
        print "\n";
        print "ip2 is ";
        print regs.ip2.mem;
        print "\n";
        print "regs mult is ";
        print regs.mult.board;
        print "\n";
        print "inc is ";
        print regs.inc;
        print "\n";
        print "ra.inc is ";
        print regs.ra.inc;
        print "\n";
        print "ram.mult.board is ";
        print ram.mult.board;
        print "\n";

        tick 1;
    }
    # tick 200;
    # print regs.instruction.mem;
    print "stepc = ";
    print regs.stepc.mem;
    print "\n";
    print "ip1 = ";
    print regs.ip1.mem;
    print "\n";
    print "regs = ";
    print regs;
    print "\n";
    print "ram[00010001] = ";
    print ram.regs[17].mem;
    print "\n";
    print "ram[00000000] = ";
    print ram.regs[0].mem;
    print "\n";
}