mod Reg (n)
{
    # input
    let and data[n];
    let and set;
    let and read;

    # output
    let and out[n];

    # memory
    let xor mem[n];
    con mem mem;

    # reset
    let and reset[n];
    con mem reset;
    con reset mem;

    # set
    con data mem;
    for i in (0, n - 1)
    {
        con set data[i];
        con set reset[i];
    }

    # read
    con mem out;
    for i in (0,  n - 1)
    {
        con read out[i];
    }
}

mod Multiplexer
{
    # input
    let or address[8];

    # output
    let and board[256];

    # negate address
    let nor neg[8];
    con address neg;

    for m in (0,255)
    {
        for n in (0, 7)
        {
            if m % 2**(n+1) < 2**(n+1) / 2
            {
                con neg[n] board[m];
            }
            else
            {
                con address[n] board[m];
            }
        }
    }
}

mod Ram (n)
{
    # input
    let or address[n];
    let or data[n];
    let or set;
    let or read;
    
    # output
    let or out[n];

    let Multiplexer mult;
    let Reg(n) regs[2**n];
    con address mult.address;

    for i in (0, 2**n - 1)
    {
        con set regs[i].set;
        con read regs[i].read;
        con mult.board[i] regs[i].set;
        con mult.board[i] regs[i].read;
        con regs[i].out out;
        con data regs[i].data;
    }
}

mod AdderSubstractor
{
    # input
    let or a[8];
    let or b[8];
    let or cin;  # carry in
    let or sub;  # signal to subtract instead of add.

    # output
    let xor sum[8];
    let or cout;  # carry out

    # invert a if subtract mode
    let xor inv_a[8];
    con a inv_a;
    for i in (0, 7)
    {
        con sub inv_a[i];
    }

    # first array  half adders
    let xor ab_sum[8];
    let and ab_cout[8];
    con a ab_sum;
    con b ab_sum;
    con inv_a ab_cout;
    con b ab_cout;

    # invert ab_sum if subtract mode
    let xor inv_ab_sum[8];
    con ab_sum inv_ab_sum;
    for i in (0, 7)
    {
        con sub inv_ab_sum[i];
    }

    # second half adder
    # sum of second half adder is `sum` from output section.
    let and cin_ab_cout[8];
    con ab_sum sum;
    con inv_ab_sum cin_ab_cout;

    # connect cout of each other to cin of next
    let or fulladder_cout[8];
    con ab_cout fulladder_cout;
    con cin_ab_cout fulladder_cout;

    con cin sum[0];
    con cin cin_ab_cout[0];
    for i in (0, 6)
    {
        con fulladder_cout[i] sum[i + 1];
        con fulladder_cout[i] cin_ab_cout[i + 1];
    }
    con fulladder_cout[7] cout;

}

mod ALU
{
    # input
    let or a[8];
    let or b[8];
    let or op_byte[8];

    # output
    let or out[8];

    # internal modules
    # need and gates for output of each internal module
    # to be able to toggle module output on and off
    # (global ALU output or's all these toggled outputs
    #  And only one should be toggled on at a time)

    let AdderSubstractor as;
    let and as_out[8];
    con a as.a;
    con b as.b;
    con as.sum as_out;
    for i in (0, 7)
    {
        con op_byte[0] as_out[i];
    }
    con as_out out;

    let or or_module[8];
    let and or_out[8];
    con a or_module;
    con b or_module;
    con or_module or_out;
    for i in (0, 7)
    {
        con op_byte[1] or_out[i];
    }
    con or_out out;

    let and and_module[8];
    let and and_out[8];
    con a and_module;
    con b and_module;
    con and_module and_out;
    for i in (0, 7)
    {
        con op_byte[2] and_out[i];
    }
    con and_out out;

    let xor xor_module[8];
    let and xor_out[8];
    con a xor_module;
    con b xor_module;
    con xor_module xor_out;
    for i in (0, 7)
    {
        con op_byte[3] xor_out[i];
    }
    con xor_out out;

    let nor not_module[8];
    let and not_out[8];
    con a not_module;
    con not_module not_out;
    for i in (0, 7)
    {
        con op_byte[4] not_out[i];
    }
    con not_out out;
}

mod Main
{
    # ram
    let Ram(8) ram;

    # registers
    let Reg(true) A;
    let Reg(true) B;
    let Reg(true) C; 

    # ALU
    let ALU alu;
}

let runtime()
{
}