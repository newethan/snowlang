script
    : (MOD IDEN LBRACE
        INPUT LBRACE wire_content RBRACE
        OUTPUT LBRACE wire_content RBRACE
        block RBRACE
        | WIRE IDEN LBRACE wire_content RBRACE)*
    ;
wire_content
    : (type IDEN SEMICOLON)*
    ;
block
    : (instruction)*
    ;
instruction
    : DEFINE type IDEN SEMICOLON
    : CONNECT item item SEMICOLON
    : LOOP VAR IN range LBRACE block RBRACE
    : IF cond_expr LBRACE block RBRACE
        (ELIF cond_expr LBRACE block RBRACE)*
        (ELSE LBRACE block RBRACE)?
    ;
item
    : IDEN (LBRACK expr RBRACK)? (PERIOD IDEN (LBRACK expr RBRACK)?)*
    ;
type
    : IDEN
    : LBRACK INT RBRACK IDEN
    ;
expr
    : term ((PLUS|MINUS) term)*
    ;
term
    : factor ((MULT|DIV) factor)*
    ;
factor
    : VAR
    : INT
    : LPAREN expr RPAREN
    ;
range
    : LPAREN expr COMMA expr RPAREN
    ;
cond_expr
    : cond_term (OR cond_term)*
    ;
cond_term
    : cond_factor (AND cond_factor)*
    ;
cond_factor
    : TRUE
    : FALSE
    : IS expr GT expr
    : IS expr GE expr
    : IS expr EQ expr
    : IS expr LE expr
    : IS expr LT expr
    : NOT cond_factor
    : LPAREN cond_expr RPAREN

examples:
```
mod 1bitreg {
    input{
        bit data;
        bit set;
    }
    output{
        bit value;
    }
    @ xor mem;
    = mem mem;
    @ or reset;
    @ and switch_on;
    @ and flip_if_on;
    = set reset;
    = reset flip_if_on;
    = mem flip_if_on;
    = flip_if_on mem;
    = set switch_on;
    = data switch_on;
    = switch_on mem;
    = mem value;
}

wire byte {
    [8]bit data;
}

mod 8bitreg {
    input{
        byte data;
        bit set;
    }
    output{
        byte value;
    }
    @ [8]1bitreg registers;
    loop $n in (1,8) {
        = data[$n] registers[$n].data;
        = set registers.set[$n];
        = registers[$n].value value[$n];
    } 
}

```